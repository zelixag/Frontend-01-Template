## css计算
### 第一步 收集css规则

  在处理html出栈的时候，进行处理style标签里面的内容

  rule有几种 

### 第二步
  当我们创建一个元素后，立即计算css，遇到第一个结束标签事结束计算

  理论上，当我们分析一个元素时，所有CSS规则已经收集完毕

  在真实浏览器中，可能遇到写在body的style 标签，需要css计算的情况，先忽略

  css重新计算   必然导致页面重排 重排必然会导致重绘

  在页面最后写入css标签会导致页面闪动，最佳实践就是把所有style标签放在最前面
  computedCSS写在哪里最合适，这个思考的地点很关键

  > 老师的思考，怎么思考的很重要
  **注意**： 理解这个代码为什么这样写
### 第三步总结
  . 在computeCSS 函数中，我们必须知道元素的所有父元素才能判断元素与规则是否匹配
  - 我们从上一步骤的stack，可以获取本元素所有的父元素
  - 因为我们首先获取的是”当前元素“， 所以我们获得和计算父元素匹配的顺序是从内向外

 > 举例子：div div #myid
 > 最里面的选择器一定匹配了“当前元素”，最里面的默认先算。然后我们一级一级的去查相关元素 
 > 例子当中先找到当前元素，再找的第一个div和第二个div。这个空格选择器子孙选择器，往父级查找 只要找到两个div的 都匹配
 
 浏览器现在一直卡着css4的复杂选择器，not选择器  not带逻辑的选择器。

 重学css的时候还会提起哪些选择器浏览器不去实现

 使用stack获取子元素的所有父元素

 真正应当使用perent去取，但是在上一步没给perent设对

 老师说混过去了。昏过去了啥呀 39：52

 建议理解完 toy 浏览器，再去看李兵老师的浏览器渲染

  标签内的style属性不参加css重新计算
 css覆盖不会出现重绘

最后一个元素都是优先处理

### 第四步 拆分选择器

加空格是复杂选择器 

连着的就是复合选择器

加逗号是选择器列表

#### 算法代码逻辑
1. 给当前元素加上computedStyle属性
2. 把rules规则一个一个拿出来（for循环rules）
3. 获取每个rule的selctors 将空格的选择器拆分出来reverse()

4.如果匹配到了当前元素直接跳出 匹配父级元素

5. 将所有元素与剩下来的选择器规则是否匹配，如果selector选择器匹配到了HTML元素，将selector下一个匹配
6. 直到selector匹配完，说明匹配成功
7. 设置匹配成功为true

##### 总结

行内样式处理，直接在element上面。

样式在绘制和排版的时候再去确定这个值

点击事件 和 定时器修改css规则都会造成大规模css重新计算，都会有重绘存在。

在页面加载好之后，一般是不会去改css rule 一般都是要么改style标签 和 class属性

元子css性能最好   css计算不超过10ms，也不用太过于关注

### 第五步 计算选择器与元素匹配

match接收一个 element和selector 

简单选择器 带. 带# 啥都不带
复合选择器：使用正则拆一下
 最复杂的复合选择器 main>div.a#id[attr=value]

 匹配就break；直接跳出循环

匹配到以后把rule里面的所有属性声明加到元素的computeStyle属性内

老师处理class属性的时候 class是空格分开的 老师没有做 额外作业是使用空格筛选出一些class名

老师只处理了class属性值只有一个的时候的情况

match可以做到一个选择器是否能够匹配到一个元素

总结： 
  - 根据选择器的类型和元素属性，计算出是否与当前元素匹配
  - 这里仅仅实现了三种基本选择器，实际的浏览器中要处理符合选择器
**作业（可选： 实现复合选择器， 实现支持空格的Class选择器在match函数里面使用for循环 indexOf不行么）**

### 第六步总结
一但选择匹配，就应用选择器到元素上。形成computedStyle

最后所有的样式都放在一个computedStyle。我们做的是style样式过来形成的computedStyle，实际上是样式和很多复杂的环境合成的

不涉及位置变化就不会重排。

### specificity
实现复合选择器的优先级

复合用个正则就一个循环加1就可以放到权重元祖里面 元组是长度固定的
  
